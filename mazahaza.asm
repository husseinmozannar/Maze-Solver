title "mazesolver" ; Program title (optional)
list p=16f84A ; Identifies device
radix hex ; Set default radix
include "p16f84A.inc" ; Includes symbol definitions
COUNT1	EQU	d'12' ; used in delay
COUNT2	EQU	d'13' ;used in delay
COUNT3	EQU	d'14' ;used
MODE_SELECT	EQU d'20' ; used to indicate mode flag bits,bit7:if mode selected,bit6:default,bit5:obstacle,bit4:maze
LCD_COLUMN	EQU d'25' 
LCD_ROW	EQU	d'26'
S1	EQU d'40' ;	CONVENTION FOR SYMBOLS: BIT7: START , BIT6: END, BIT5:OBSTACLE,BIT4: EMPTY, BIT3:VISITED
S2	EQU d'41'
S3	EQU d'42'
S4	EQU d'43'
S5	EQU d'44'
S6	EQU d'45'
S7	EQU d'46'
S8	EQU d'47'
S9	EQU d'48'
S10	EQU d'49'
S11	EQU d'50'
S12	EQU d'51'
S13	EQU d'52'
S14	EQU d'53'
S15	EQU d'54'
S16	EQU d'55'
S17	EQU d'56'
S18	EQU d'57'
S19	EQU d'58'
S20	EQU d'59'
OBS_CLOCK	EQU d'65' 
COUNT_OBSTACLE	EQU	d'66' ; TO KNOW HOW MANY OBSTACLE WE WENT THROUGH
TO_PUT	EQU	d'67'







	ORG 0x0
	GOTO MAIN ; main program
	ORG 0x4 ; start of interrupt routine
	BTFSC	INTCON,RBIF
	GOTO	RBINT
	GOTO	TMR0INT

	; here check source of interrupt and call routine and end routine with RETFIE	



MAIN
	BSF	STATUS,RP0 ; GO TO BANK 1
	 ; set portA as output
	MOVLW	b'11110000'
	MOVWF	TRISB ;SET PORT B AS INPUT AND OUTPUT ,MSB FIRST
	CLRF	TRISA ; SET PORT A AS OUTPUT
	BCF	STATUS,RP0 ; GO TO BANK 0
	CALL	DELAY40ms ; WAIT FOR POWER ON
	MOVLW	B'00010' 
	CALL	WRITE
	MOVLW	B'00010' 
	CALL	WRITE
	MOVLW	B'01000' ; 2 line mode and 5x7
	CALL	WRITE
	MOVLW	B'00000' 
	CALL	WRITE
	MOVLW	B'01110' ; display ON ,CURSOR OFF, BLINK OFF 
	CALL	WRITE

	MOVLW	B'00000' 
	CALL	WRITE

	MOVLW	B'00001' ;CLEAR DISPLAY
	CALL	WRITE

	MOVLW	B'00000' 
	CALL	WRITE

	MOVLW	B'00110' ; INCREMENT AND SHIFT OFF
	CALL	WRITE;DONE 4 BIT MODE LCD
	CALL	WRITE_MAZE ;;;;;;;;;;;;;;;;;;;;;; anthony: recommendation: place "clear display" right above this, when game finishes we come back here, AND CLEAR INTCON!!

	CALL	WRITE_WHITESPACE
	CALL	WRITE_S
	MOVLW	B'10100';O
	CALL	WRITE
	MOVLW	B'11111'
	CALL	WRITE

	MOVLW	B'10100';L
	CALL	WRITE
	MOVLW	B'11100'
	CALL	WRITE

	MOVLW	B'10101';V
	CALL	WRITE
	MOVLW	B'10110'
	CALL	WRITE
	CALL	WRITE_E
	MOVLW	B'10101';R
	CALL	WRITE
	MOVLW	B'10010'
	CALL	WRITE ; END WRITING MAZE SOLVER,  ,TILL NOW GOOD

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	MOVLW	B'00000' ;CLEAR DISPLAY 
	CALL	WRITE
	MOVLW	B'00001' ;CLEAR DISPLAY
	CALL	WRITE
	
	CALL	WRITE_WHITESPACE
	CALL	WRITE_WHITESPACE
	CALL	WRITE_WHITESPACE
	CALL	WRITE_STAR
	MOVLW	B'10100';D DEFAULT STARTS HERE
	CALL	WRITE
	MOVLW	B'10100'
	CALL	WRITE	

	CALL	WRITE_E

	MOVLW	B'10100';F
	CALL	WRITE
	MOVLW	B'10110'
	CALL	WRITE

	CALL	WRITE_A

	MOVLW	B'10101';U
	CALL	WRITE
	MOVLW	B'10101'
	CALL	WRITE

	MOVLW	B'10100';L
	CALL	WRITE
	MOVLW	B'11100'
	CALL	WRITE

	MOVLW	B'10101';T
	CALL	WRITE
	MOVLW	B'10100'
	CALL	WRITE ; END OF DEFAULT

	MOVLW	B'00001100';change line +1 
	CALL	WRITE
	MOVLW	B'00000001'
	CALL	WRITE
	
	MOVLW	B'10100';O
	CALL	WRITE
	MOVLW	B'11111'
	CALL	WRITE
	MOVLW	B'10100';B
	CALL	WRITE
	MOVLW	B'10010'
	CALL	WRITE
	CALL	WRITE_S
	MOVLW	B'10101';T
	CALL	WRITE
	MOVLW	B'10100'
	CALL	WRITE
	CALL	WRITE_A
	MOVLW	B'10100';C
	CALL	WRITE
	MOVLW	B'10011'
	CALL	WRITE
	MOVLW	B'10100';L
	CALL	WRITE
	MOVLW	B'11100'
	CALL	WRITE
	CALL	WRITE_E
	CALL	WRITE_WHITESPACE
	CALL	WRITE_WHITESPACE
	CALL	WRITE_WHITESPACE
	CALL	WRITE_MAZE
	CLRF	MODE_SELECT
	CLRF	PORTB ; hayde lachou dakhlak? 
	BSF	MODE_SELECT,6
	BSF	INTCON,GIE
	BSF	INTCON,RBIE
	infLOOP	GOTO	infLOOP ;;;;; extra comments: check for option register: interrupt on low edge of signals

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;																																													  ;
;																																													  ;
;																																												      ;																																													  ;
;																																													  ;
;																																													  ;
;							       SUBROUTINES																																	  ;
;									GO HERE																																	  ;
;										|																																			  ;
;										|																																			  ;
;										|																																			  ;
;										V																																			  ;
;																																													  ;
;																																													  ;
;																																													  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

WRITE_REM_OBS_5
		MOVLW	B'01000';SET OBS ADDRESS
		CALL	WRITE
		MOVLW	B'01100';
		CALL	WRITE

		MOVLW	B'10100';O
		CALL	WRITE
		MOVLW	B'11111'
		CALL	WRITE
		MOVLW	B'10100';B
		CALL	WRITE
		MOVLW	B'10010'
		CALL	WRITE
		CALL	WRITE_S ; WROTE OBS

		MOVLW	B'01100';SET REM ADDRESS
		CALL	WRITE
		MOVLW	B'01011';
		CALL	WRITE

		MOVLW	B'10101';R
		CALL	WRITE
		MOVLW	B'10010'
		CALL	WRITE
		CALL	WRITE_E
		MOVLW	B'10100';M
		CALL	WRITE
		MOVLW	B'11101'
		CALL	WRITE ; WROTE REM
		CALL	WRITE_WHITESPACE
	
		MOVLW	B'10011'; 5
		CALL WRITE
		MOVLW	B'10101'
		CALL WRITE
		
		CLRF	REM_OBS
		BSF	REM_OBS,3
;RETURN????
WRITE_REM_NUM
	;MUST HAVE REGISTER TO COUNT OBSTACLES REM
	BTFSC	REM_OBS,3
	CALL	PRINT4
	BTFSC	REM_OBS,2
	CALL	PRINT3
	BTFSC	REM_OBS,1
	CALL	PRINT2
	BTFSC	REM_OBS,0
	CALL	PRINT1
	



PRINT4
	CALL	REM_NUM_ADDRESS
	
	MOVLW	B'10011'; 4
	CALL WRITE
	MOVLW	B'10100'
	CALL WRITE
	
	CALL	GO_BACK_CURSOR
	RETURN
PRINT3
	CALL	REM_NUM_ADDRESS
	
	MOVLW	B'10011'; 3
	CALL WRITE
	MOVLW	B'10011'
	CALL WRITE
	
	CALL	GO_BACK_CURSOR
	RETURN
PRINT2
	CALL	REM_NUM_ADDRESS
	
	MOVLW	B'10011'; 2
	CALL WRITE
	MOVLW	B'10010'
	CALL WRITE
	
	CALL	GO_BACK_CURSOR
	RETURN
PRINT1
	CALL	REM_NUM_ADDRESS
	
	MOVLW	B'10011'; 1
	CALL WRITE
	MOVLW	B'10001'
	CALL WRITE
	
	CALL	GO_BACK_CURSOR
	RETURN
PRINT0
	CALL	REM_NUM_ADDRESS
	
	MOVLW	B'10011'; 0
	CALL WRITE
	MOVLW	B'10000'
	CALL WRITE
	
	CALL	GO_BACK_CURSOR
	RETURN

REM_NUM_ADDRESS
	MOVLW	B'01100';SET NUM ADDRESS 
	CALL	WRITE
	MOVLW	B'01111'
	CALL	WRITE;
	RETRUN
	
GO_BACK_CURSOR
	MOVF	LCD_ROW,0
	CALL	WRITE
	MOVF	LCD_COLUMN
	CALL	WRITE
	RETRUN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RBINT
		CALL	DELAYonemilli
		BTFSC	PORTB,4 ; check here source of interrupt and call appropriate subroutine
		GOTO	INT5
		GOTO	MOVE 
INT5	BTFSC	PORTB,5
		GOTO	INT6
		GOTO	CONFIRM
INT6	BTFSC	PORTB,6
		GOTO	INT7
		GOTO 	START
INT7	BTFSC	PORTB,7
		GOTO	RETY
		GOTO	ENDPOINT
RETY	BCF	INTCON,RBIF ; Anthony's fix: was INTF instead of RBIF
		RETFIE

MOVE
		BTFSS	MODE_SELECT,7 ; if we pressed move, we check if we already selected a mode
		GOTO	POINTER_MOVE ;else move pointer CALL OR GOTO???
		BTFSS	MODE_SELECT,5 ;now if we are in our obstacle mode
		GOTO	RETY
		GOTO	OBSTACLE_MOVE
		
		;DO FOR OBSTACLE MODE LATER	

	

OBSTACLE_MOVE
		BTFSC	FSR,1 ; IF END OF ROW 2 ,BETTER WAY IS TO CHECK IF FSR=S11 , I HAVE SET FOR OBSTACLE 11 ( END OF ROW 2 ) BIT1=1 
		GOTO	RETY ;SHOULD CALL ALGORITHM BEFORE !!!
		BTFSC	FSR,0 ; IF END OF ROW1 ,IF ELSE STRUCTURE, CHECK FSR=S10 ,I HAVE SET FOR OBSTACLE 10 ( END OF ROW 1 ) BIT0=1 
		CALL	SET_ROW1
		BTFSC	OBS_CLOCK,0
		GOTO	MOVE_DEC
		GOTO	MOVE_INC
MOVE_INC
		MOVLW	B'00001' ; THIS IS MOVE CURSOR
		CALL	WRITE
		MOVLW	B'00100' ;RIGHT
		CALL	WRITE
		INCF	FSR
		CALL	DELAY200ms		
		GOTO RETY
MOVE_DEC
		MOVLW	B'00001' ; THIS IS MOVE CURSOR
		CALL	WRITE
		MOVLW	B'00000' ;LEFT
		CALL	WRITE
		DECF	FSR
		CALL	DELAY200ms
		GOTO	RETY
	

DELAY200ms ;ah fuck it ;
		CALL	DELAY40ms	
		CALL	DELAY40ms
		CALL	DELAY40ms
		CALL	DELAY40ms	
		CALL	DELAY40ms
		CALL	DELAY40ms
		CALL	DELAY40ms
		CALL	DELAY40ms
		RETURN

SET_ROW1 ; BELONGS TO OBSTACLE MOVE
		MOVLW	B'00001100';change line +1 
		CALL	WRITE
		MOVLW	B'00001001' ; 9TH COLUMN 
		CALL	WRITE
		BSF	OBS_CLOCK,0 ;SET IT TO 1 MEANING DEC
		movlw	d'59' ;8TH COLUMN
		movwf	FSR ;to RAM
		RETURN


CONFIRM
	BTFSS	MODE_SELECT,7
	GOTO	CONFIRM_FALSE ;DONE 
	GOTO	CONFIRM_TRUE ;NEED TO DO !!!
		
CONFIRM_FALSE
		BSF	MODE_SELECT,7
		BTFSS	MODE_SELECT,6
		GOTO	CHECK_5
		GOTO	DEFAULT_INIT;ADD GOTO RETY IN THE END
CHECK_5	BTFSS	MODE_SELECT,5
		GOTO	CHECK_4
		GOTO	OBSTACLE_INIT
CHECK_4	GOTO	MAZE_INIT


CONFIRM_TRUE
		BTFSS	MODE_SELECT,6
		GOTO	CALL_5
		GOTO	DEFAULT_RUN;ADD GOTO RETY IN THE END
CALL_5	BTFSS	MODE_SELECT,5
		GOTO	CALL_4
		GOTO	OBSTACLE_DO ; NEED TO DO
CALL_4	CALL	MAZE_DO ;NEED TO DO


OBSTACLE_DO
		 ; try to put obstacle , and increment obstacle count if succesfuul : its own subroutine
		;make 1 subroutine tha takes to_put as argument 
		; at the end check if number of obstacles has reached its limit, if so call algorithm 
		MOVLW	b'00100000'
		MOVWF	TO_PUT	; PREPARE ARGUMENT AS OBSTACLE	
		CALL	PLACE_ITEM
		CALL	DELAY200ms ;debounce delay
		BTFSC	COUNT_OBSTACLE,4 ;CHECK IF 5 TIMES SHIFTED LEFT
		GOTO	RETY ; SHOULD CALL ALGORITHM IN PLACE and stop all other stuff
		GOTO	RETY
		
PLACE_ITEM
		BTFSC	INDF,4 ;CHECK IF EMPTY
		GOTO	PLACE_TRUE
		GOTO	PLACE_FALSE
PLACE_TRUE	
		BTFSC	TO_PUT,7
		CALL	WRITE_S
		BTFSC	TO_PUT,6
		CALL	WRITE_E
		BTFSC	TO_PUT,5
		CALL	WRITE_RECT
		BTFSC	TO_PUT,3
		CALL	WRITE_STAR
		RLF	COUNT_OBSTACLE
		INCF	COUNT_OBSTACLE
		RETURN ; 
PLACE_FALSE
		BSF	PORTB,0
		CALL	DELAY200ms
		BCF	PORTB,0
		RETURN

OBSTACLE_INIT
		MOVLW	B'00000' ;CLEAR DISPLAY 
		CALL	WRITE
		MOVLW	B'00001' ;CLEAR DISPLAY
		CALL	WRITE
		;FIRST CLEAR DISPLAY
		CALL	MAZE_INIT_EMPTY
		CLRF	S1
		BSF	S1,7 ;START
		CLRF	S20
		BSF	S20,6 ;HAVE PUT THE START AND END POINTS
		BSF	S10,0 ;BOUNDS
		BSF	S11,1 ;BOUNDS
		CALL	PRINT_MAZE
		CALL	WRITE_COORD
		MOVLW	B'00000';	set cursor on, blink on, display on. 
		CALL	WRITE
		MOVLW	B'01111'
		CALL	WRITE
		BSF	PORTB,3 ;green LED on
		MOVLW	d'41'
		MOVWF	FSR; 
		MOVLW	b'00000000'
		MOVF	OBS_CLOCK
		MOVF	COUNT_OBSTACLE
		MOVLW	b'00000001'
		MOVF	LCD_COLUMN
		MOVLW	b'00001000'
		MOVF	LCD_ROW
		MOVLW	B'00001000';change line +1 
		CALL	WRITE
		MOVLW	B'00000001' ;start from 2nd column , works
		CALL	WRITE	
		;INITIALIZE FSR ,AND SET POINTER TO FIRST OF SCREEN, INITALIZE LCD ADRESS TO 0
		; initialize obs_clock to 0
		;INITIALIZE COUNT_OBS TO 0
		GOTO RETY ;PRINTED AND INITALIZED MAZE 
		

DEFAULT_RUN 
		;CALL ALGORITHM
		GOTO RETY

DEFAULT_INIT	
		; CLEAR DISPLAY
		MOVLW	B'00000' ;CLEAR DISPLAY 
		CALL	WRITE
		MOVLW	B'00001' ;CLEAR DISPLAY
		CALL	WRITE
		CALL	MAZE_INIT_EMPTY

		CLRF	S1
		BSF	S1,5 ;OBS
		CLRF	S12
		BSF	S12,5 ;OBS
		CLRF	S14
		BSF	S14,5 ;OBS
		CLRF	S15
		BSF	S15,5 ;OBS
		CLRF	S19
		BSF	S19,5 ;OBS
		CLRF	S20
		BSF	S20,5 ;OBS
		CLRF	S6
		BSF	S10,0 ; INDICATE END OF FIRST ROW
		BSF	S6,7;START
		CLRF	S11 ;END
		BSF	S11,1 ; INDICATE END OF SECOND ROW ; anthony's fix: CLRF S11 was after this instruction, bad. AND: keep s11 as last column or S20???
		BSF	S11,6	;INITIALIZED MAZE PROPERLY
		CALL	PRINT_MAZE ;printed maze
		CALL	WRITE_COORD
		MOVLW	B'00000';	set cursor on, blink on, display on. 
		CALL	WRITE
		MOVLW	B'01111'
		CALL	WRITE
		
		BSF	PORTB,2 ; red led lel
		GOTO RETY





MAZE_DO
MAZE_INIT
START; DO
ENDPOINT;DO
TMR0INT;DO




POINTER_MOVE ; USED FOR MODE SELECTION
		BTFSS	MODE_SELECT,6
		GOTO	CHECK5
		MOVLW	B'01000';GO TO DEFAULT  address
		CALL	WRITE
		MOVLW	B'00011'
		CALL	WRITE
		CALL	WRITE_WHITESPACE ;remove *
		MOVLW	B'01100';GO TO OBSTACLE 
		CALL	WRITE
		MOVLW	B'00000'
		CALL	WRITE
		CALL	WRITE_STAR
		BCF	MODE_SELECT,6
		BSF	MODE_SELECT,5
		GOTO	RETY
CHECK5
		BTFSS	MODE_SELECT,5
		GOTO	CHECK4
		MOVLW	B'01100';GO TO OBSTACLE 
		CALL	WRITE
		MOVLW	B'00000'
		CALL	WRITE
		CALL	WRITE_WHITESPACE
		MOVLW	B'01100';GO TO MAZE
		CALL	WRITE
		MOVLW	B'01011'
		CALL	WRITE
		CALL	WRITE_STAR
		BCF	MODE_SELECT,5
		BSF	MODE_SELECT,4
		GOTO	RETY
CHECK4	
		MOVLW	B'01100';GO TO MAZE
		CALL	WRITE
		MOVLW	B'01011'
		CALL	WRITE
		CALL	WRITE_WHITESPACE
		MOVLW	B'01000';GO TO DEFAULT add 
		CALL	WRITE
		MOVLW	B'00011'
		CALL	WRITE
		CALL	WRITE_STAR
		CLRF	MODE_SELECT
		BSF	MODE_SELECT,6
		GOTO	RETY

WRITE__
	MOVLW	B'10101';_
	CALL	WRITE
	MOVLW	B'11111'
	CALL	WRITE
	RETURN
WRITE_RECT
	MOVLW	B'11111';||
	CALL	WRITE
	MOVLW	B'11111'
	CALL	WRITE
	RETURN
WRITE_STAR
	MOVLW	B'10010';*
	CALL	WRITE
	MOVLW	B'11010'
	CALL	WRITE
	RETURN

WRITE_WHITESPACE
		MOVLW	b'10010'
		CALL	WRITE
		MOVLW	B'10000'
		CALL	WRITE
		RETURN

WRITE_S	
		MOVLW	b'10101'
		CALL	WRITE
		MOVLW	B'10011'
		CALL	WRITE
		RETURN

WRITE_A 
		MOVLW	B'10100';A
		CALL	WRITE
		MOVLW	B'10001'
		CALL	WRITE
		RETURN

WRITE_E
		MOVLW	B'10100';E
		CALL	WRITE
		MOVLW	B'10101'
		CALL	WRITE
		RETURN


WRITE	MOVWF	PORTA ;TO WRITE TO LCD
		CALL	ET
		RETURN

WRITE_MAZE 
		MOVLW	B'10100';M
		CALL	WRITE
		MOVLW	B'11101'
		CALL	WRITE
		CALL	WRITE_A
		MOVLW	B'10101';Z
		CALL	WRITE
		MOVLW	B'11010'
		CALL	WRITE
		CALL	WRITE_E
		RETURN


MAZE_INIT_EMPTY; USED TO SET THE MAZE ALL EMPTY 
		movlw	d'40' ;initialize pointer   THIS IS USED TO READ THE SYMBOLS OF OUR MAZE, we intialize the FSR to the address and read from the INDF register
		movwf	FSR ;to RAM
		movlw	d'21' ;checkkk
		movwf	COUNT3
MAZE_INIT_LOOP
		DECFSZ	COUNT3,F ;ITERATE 20 times
		GOTO	MAZE_INIT_ACTION
		RETURN
MAZE_INIT_ACTION
		CLRF	INDF
		BSF	INDF,4 ;SET 4TH BIT TO 1: EMPTY
		INCF	FSR
		GOTO	MAZE_INIT_LOOP			


PRINT_MAZE ;used to print maze on LCD
		MOVLW	B'01000';GO TO START OF	LCD
		CALL	WRITE
		MOVLW	B'00000'
		CALL	WRITE
		movlw	d'40' ;initialize pointer   
		movwf	FSR ;
		CALL	PRINT_MAZE_SUB
		MOVLW	B'01100';GO TO SECOND LINE
		CALL	WRITE
		MOVLW	B'00000'
		CALL	WRITE
		movlw	d'50' ;initialize pointer   
		movwf	FSR ;
		CALL	PRINT_MAZE_SUB
		RETURN

PRINT_MAZE_SUB
		movlw	d'11'
		movwf	COUNT3
PRINT_MAZE_LOOP
		DECFSZ	COUNT3,F
		GOTO	PRINT_MAZE_ACTION
		RETURN
PRINT_MAZE_ACTION
		BTFSC	INDF,7
		CALL	WRITE_S
		BTFSC	INDF,6
		CALL	WRITE_E
		BTFSC	INDF,5
		CALL	WRITE_RECT
		BTFSC	INDF,4
		CALL	WRITE__
		BTFSC	INDF,3
		CALL	WRITE_STAR
		INCF	FSR
		GOTO	PRINT_MAZE_LOOP
		

ET	BSF	PORTB,1;subroutine to send messages to LCD: toogle routine, can USE 10ms instead of 40ms
	NOP
	BCF	PORTB,1
	CALL	DELAY40ms ; do it in 10ms if we have code lines
	RETURN

DELAYonemilli	Movlw	H'07'
	movwf	COUNT2
LOOPP	NOP
	INCFSZ	COUNT2,F
	GOTO	LOOPP
	RETURN


DELAY40ms	MOVLW	H'00' ;40 ms delay subroutine
	MOVWF	COUNT2
	MOVLW	D'52'
	MOVWF	COUNT1
LOOP	
	INCFSZ	COUNT2,F
	GOTO	LOOP
	DECFSZ	COUNT1,F
	GOTO	LOOP
	RETURN

WRITE_COORD
	MOVLW	B'01000';SET ADDRS AT 0X0D 
	CALL	WRITE
	MOVLW	B'01101'
	CALL	WRITE	
	CALL WRITE_S
	CALL	WRITE_WHITESPACE
	MOVLW	B'10100'; @
	CALL	WRITE
	MOVLW	B'10000'
	CALL	WRITE
	
	MOVLW	B'01100';SET ADDRS AT 0X4D 
	CALL	WRITE
	MOVLW	B'01101'
	CALL	WRITE
	
	MOVLW	B'10011'; 0
	CALL	WRITE
	MOVLW	B'10000'
	CALL	WRITE	

	MOVLW	B'10010'; WRITE "," 
	CALL	WRITE
	MOVLW	B'11100'
	CALL	WRITE

	BTFSS	MODE_SELECT,6
	GOTO	SKEEPEE ; IF BIT 6 IS 0, THIS MEANS I AM IN OBSTACLE(IMPLEMENTED IN SKEEPEE)
	MOVLW	B'10011'; WRITE 5 
	CALL	WRITE
	MOVLW	B'10101'
	CALL	WRITE	
	RETURN
SKEEPEE	
	MOVLW	B'10011'; 0
	CALL	WRITE
	MOVLW	B'10000'
	CALL	WRITE
	RETURN
	END ; last in program